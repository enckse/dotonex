#!/usr/bin/python
import argparse
import os
import time
import subprocess
import configparser

_SERVER = "server"
_LOCAL = ".local"
_TOKEN = "token"
_VLAN_CFG = "vlans.cfg"

def _local_file(repo, name):
    return os.path.join(repo, name + _LOCAL)


class ConfigException(Exception):
    pass


def _is_mac(mac):
    m = mac.lower()
    if len(m) != 12:
        return False
    for c in m:
        if (c >= 'a' and c <= 'f') or (c >= '0' and c <= '9'):
            continue
        return False
    return True


def _users(repo, vlan_names):
    users = []
    password = _local_file(repo, _SERVER)
    if not os.path.exists(password):
        raise ConfigException("no password for login found")
    with open(password, 'r') as f:
        password = f.read().strip()
    for f in os.listdir(repo):
        mab = f in vlan_names
        cfg_dir = os.path.join(repo, f)
        if mab:
            print("{} (MAB)".format(f))
            for mac in os.listdir(cfg_dir):
                if not _is_mac(mac):
                    continue
                print(" -> {}".format(mac))
                users.append(Hostapd(mac, mac, f))
        else:
            possible = os.path.join(cfg_dir, _VLAN_CFG)
            if not os.path.exists(possible):
                continue
            secret = _local_file(cfg_dir, _TOKEN)
            if not os.path.exists(secret):
                continue
            print("{} (USER)".format(f))
            user_name = ""
            with open(secret, 'r') as data:
                user_name = data.read().strip()
            if user_name == "":
                continue
            vlans = []
            with open(possible, 'r') as data:
                cfg = configparser.ConfigParser()
                cfg.read_string(data.read())
                vlans = [x for x in cfg.sections() if x in vlan_names]
                first = True
                for v in vlans:
                    if first:
                        users.append(Hostapd(user_name, password, v))
                    users.append(Hostapd("{}:{}".format(v, user_name), password, v))
                    first = False
    return users


class Hostapd(object):
    def __init__(self, name, password, vlan):
        self.name = name
        self.password = password
        self.vlan = vlan
        self.mab = name == password

    def to_string(self, vlan_id):
        login = ""
        attr = """
radius_accept_attr=64:d:13
radius_accept_attr=65:d:6
radius_accept_attr=81:s:{}""".format(vlan_id)
        if self.mab:
            login = "\"{}\" MD5 \"{}\"".format(self.name, self.name)
        else:
            login = """
\"{}\" PEAP

\"{}\" MSCHAPV2 hash:{} [2]""".format(self.name, self.name, self.password)
        return login + attr



def _build_configuration(repo):
    vlan_cfg = os.path.join(repo, _VLAN_CFG)
    if not os.path.exists(vlan_cfg):
        raise ConfigException("vlans missing")
    vlans = []
    with open(vlan_cfg, 'r') as f:
        cfg = configparser.ConfigParser()
        cfg.read_string(f.read())
        names = cfg.sections()
        for n in names:
            section = cfg[n]
            if "id" not in section:
                raise ConfigException("no vlan id found: {}".format(n))
            vlans.append((n, section["id"]))
    vlan_names = [x[0] for x in vlans]
    users = _users(repo, vlan_names)
    hostapd = []
    for u in users:
        vlan_id = [x[1] for x in vlans if x[0] == u.vlan]
        if len(vlan_id) != 1:
            print("invalid vlan configuration")
            continue
        hostapd.append(u.to_string(vlan_id[0]))
    if len(hostapd) == 0:
        print("no hostapd data found")
        return
    eap_user = os.path.join(repo, "eap_users")
    next_eap = eap_user + ".next"
    with open(next_eap, 'w') as f:
        f.write("\n\n".join(sorted(hostapd)) + "\n")
    if os.path.exists(eap_user):
        if subprocess.call(["diff", "-u", eap_user, next_eap]) == 0:
            return
    subprocess.call(["mv", next_eap, eap_user])
    print("hostapd reset")
    _reset_hostapd()


def _reset_hostapd():
    pids = _run_piped(["pidof", "hostapd"])
    for p in [x.strip() for x in pids.split("\n")]:
        if p:
            print("signaling {}".format(p))
            subprocess.call(["kill", "-HUP", p])


def _server(repo, pass_hash):
    hash_file = _local_file(repo, _SERVER)
    if os.path.exists(hash_file):
        with open(hash_file, 'r') as f:
            if f.read().strip() == pass_hash:
                return
    print("hash update")
    with open(hash_file, 'w') as f:
        f.write(pass_hash)
    _build(repo, True)


def _run_piped(cmd):
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    o, e = p.communicate()
    if e is not None and e != b'':
        print(cmd)
        print(e)
        raise ConfigException("command failed")
    return o.decode("utf-8").strip()


def _build(repo, force):
    if not force:
        last = _run_piped(["git", "-C", repo, "log", "-n", "1", "--format=%h"])
        if len(last) == 0:
            raise ConfigException("unable to retrieve hash")
        last_file = _local_file(repo, "commit")
        if os.path.exists(last_file):
            with open(last_file, 'r') as f:
                if f.read().strip() == last:
                    print("no configuration changes found")
                    return
        with open(last_file, 'w') as f:
            f.write(last)
    _build_configuration(repo)


def _fetch(repo):
    for cmd in ["fetch", "pull"]:
        rt = subprocess.call(["git", "-C", repo, cmd])
        if rt != 0:
            raise ConfigException("{} git command failed".format(cmd))


def main():
    """Program entry."""
    parser = argparse.ArgumentParser()
    parser.add_argument("mode", help="action to perform")
    parser.add_argument("repository", help="repository to operate from")
    parser.add_argument("--url", help="url to confirm user tokens with")
    parser.add_argument("--hash", help="shared server password hash")
    parser.add_argument("--mac", help="calling mac")
    parser.add_argument("--token", help="token to confirm")
    try:
        args = parser.parse_args()
        if not os.path.exists(args.repository):
            raise ConfigException("repository does not exist")
        if args.mode == "validate":
            if not args.url or not args.token or not args.mac:
                raise ConfigException("url, token, and mac required")
            _validate(args.repository, args.url, args.token, args.mac)
        elif args.mode == "server":
            if not args.hash:
                raise ConfigException("hash required")
            _server(args.repository, args.hash)
        elif args.mode == "update":
            _fetch(args.repository)
            _build(args.repository, False)
        elif args.mode == "build":
            _build(args.repository, True)
        else:
            raise ConfigException("unknown mode: {}".format(args.mode))
    except Exception as e:
        print("configuration process failed")
        print(e)
        exit(1)


if __name__ == "__main__":
    main()

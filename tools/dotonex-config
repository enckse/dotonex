#!/usr/bin/python
import argparse
import os
import time
import subprocess
import configparser
import json

_SERVER = "server"
_LOCAL = ".local"
_TOKEN = "token"
_VLAN_CFG = "vlans.cfg"


def _local_file(repo, name):
    return os.path.join(repo, name + _LOCAL)


def _stdout(message):
    print("[SCRIPTLET] {}".format(message))


class ConfigException(Exception):
    pass


def _is_mac(mac):
    m = mac.lower()
    if len(m) != 12:
        return None
    cleaned = []
    for c in m:
        if (c >= 'a' and c <= 'f') or (c >= '0' and c <= '9'):
            cleaned.append(c)
            continue
        return None
    return "".join(cleaned)


def _users(repo, vlan_names):
    users = []
    password = _local_file(repo, _SERVER)
    if not os.path.exists(password):
        raise ConfigException("no password for login found")
    with open(password, 'r') as f:
        password = f.read().strip()
    for f in os.listdir(repo):
        mab = f in vlan_names
        cfg_dir = os.path.join(repo, f)
        if mab:
            _stdout("{} (MAB)".format(f))
            for mac in os.listdir(cfg_dir):
                if _is_mac(mac) is None:
                    continue
                _stdout(" -> {}".format(mac))
                users.append(Hostapd(mac, mac, f))
        else:
            possible = os.path.join(cfg_dir, _VLAN_CFG)
            if not os.path.exists(possible):
                continue
            secret = _local_file(cfg_dir, _TOKEN)
            if not os.path.exists(secret):
                continue
            _stdout("{} (USER)".format(f))
            user_name = ""
            with open(secret, 'r') as data:
                user_name = data.read().strip()
            if user_name == "":
                continue
            vlans = []
            with open(possible, 'r') as data:
                cfg = configparser.ConfigParser()
                cfg.read_string(data.read())
                vlans = [x for x in cfg.sections() if x in vlan_names]
                first = True
                for v in vlans:
                    if first:
                        users.append(Hostapd(user_name, password, v))
                    users.append(Hostapd("{}:{}".format(v, user_name),
                                         password,
                                         v))
                    first = False
    return users


class Hostapd(object):
    def __init__(self, name, password, vlan):
        self.name = name
        self.password = password
        self.vlan = vlan
        self.mab = name == password

    def to_string(self, vlan_id):
        login = ""
        attr = """
radius_accept_attr=64:d:13
radius_accept_attr=65:d:6
radius_accept_attr=81:s:{}""".format(vlan_id)
        if self.mab:
            login = "\"{}\" MD5 \"{}\"".format(self.name, self.name)
        else:
            login = """
\"{}\" PEAP

\"{}\" MSCHAPV2 hash:{} [2]""".format(self.name, self.name, self.password)
        return login + attr


def _build_configuration(repo):
    vlan_cfg = os.path.join(repo, _VLAN_CFG)
    if not os.path.exists(vlan_cfg):
        raise ConfigException("vlans missing")
    vlans = []
    with open(vlan_cfg, 'r') as f:
        cfg = configparser.ConfigParser()
        cfg.read_string(f.read())
        names = cfg.sections()
        for n in names:
            section = cfg[n]
            if "id" not in section:
                raise ConfigException("no vlan id found: {}".format(n))
            vlans.append((n, section["id"]))
    vlan_names = [x[0] for x in vlans]
    users = _users(repo, vlan_names)
    hostapd = []
    for u in users:
        vlan_id = [x[1] for x in vlans if x[0] == u.vlan]
        if len(vlan_id) != 1:
            _stdout("invalid vlan configuration")
            continue
        hostapd.append(u.to_string(vlan_id[0]))
    if len(hostapd) == 0:
        _stdout("no hostapd data found")
        return
    eap_user = os.path.join(repo, "eap_users")
    next_eap = eap_user + ".next" + _LOCAL
    with open(next_eap, 'w') as f:
        f.write("\n\n".join(sorted(hostapd)) + "\n")
    if os.path.exists(eap_user):
        if subprocess.call(["diff", "-u", eap_user, next_eap]) == 0:
            return
    subprocess.call(["mv", next_eap, eap_user])
    _stdout("hostapd reset")
    _reset_hostapd()


def _reset_hostapd():
    pids = _run_piped(["pidof", "hostapd"])
    for p in [x.strip() for x in pids.split("\n")]:
        if p:
            _stdout("signaling {}".format(p))
            subprocess.call(["kill", "-HUP", p])


def _server(repo, pass_hash):
    hash_file = _local_file(repo, _SERVER)
    if os.path.exists(hash_file):
        with open(hash_file, 'r') as f:
            if f.read().strip() == pass_hash:
                return
    _stdout("hash update")
    with open(hash_file, 'w') as f:
        f.write(pass_hash)
    _build(repo, True)


def _run_piped(cmd):
    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    o, e = p.communicate()
    if e is not None and e != b'':
        _stdout(cmd)
        _stdout(e)
        raise ConfigException("command failed")
    return o.decode("utf-8").strip()


def _build(repo, force):
    if not force:
        last = _run_piped(["git", "-C", repo, "log", "-n", "1", "--format=%h"])
        if len(last) == 0:
            raise ConfigException("unable to retrieve hash")
        last_file = _local_file(repo, "commit")
        if os.path.exists(last_file):
            with open(last_file, 'r') as f:
                if f.read().strip() == last:
                    _stdout("no configuration changes found")
                    return
        with open(last_file, 'w') as f:
            f.write(last)
    _build_configuration(repo)


def _fetch(repo):
    for cmd in ["fetch", "pull"]:
        rt = subprocess.call(["git", "-C", repo, cmd])
        if rt != 0:
            raise ConfigException("{} git command failed".format(cmd))


def _validate(repo, command, token, mac):
    """Validate a user."""
    _stdout('validating inputs')
    cleaned_mac = _is_mac(mac)
    if cleaned_mac is None:
        _stdout("invalid mac: {}".format(mac))
        return
    known_file = _local_file(repo, "known")
    new_known = known_file + ".next" + _LOCAL
    known = {}
    if os.path.exists(known_file):
        with open(known_file, 'r') as f:
            known = json.loads(f.read())
    user_name = None
    if token in known:
        user_name = known[token]
    changed = False
    if user_name is None:
        try:
            o = _run_piped([x.format(token) for x in command])
            j = json.loads(o)
            if "name" not in j:
                _stdout(o)
                raise ConfigException("key not found in response")
            user_name = j["name"]
            _stdout("inserting {} for {}".format(token, user_name))
            known[token] = user_name
            changed = True
            _stdout('validation complete')
        except Exception as e:
            _stdout("lookup failed")
            _stdout(e)
            exit(1)
    if user_name is None:
        exit(1)
    _stdout("user found: {}".format(user_name))
    user_dir = os.path.join(repo, user_name)
    if changed:
        _stdout("user token is new")
        data = json.dumps(known)
        with open(new_known, "w") as f:
            f.write(data)
        subprocess.call(["mv", new_known, known_file])
        with open(_local_file(user_dir, _TOKEN), 'w') as f:
            f.write(token)
        _build(repo, True)
    exit_code = 0
    for f in [cleaned_mac, _VLAN_CFG]:
        if not os.path.exists(os.path.join(user_dir, f)):
            _stdout("invalid: {}".format(f))
            exit_code = 1
    _stdout("valid")
    exit(exit_code)


def main():
    """Program entry."""
    parser = argparse.ArgumentParser()
    parser.add_argument("mode", help="action to perform")
    parser.add_argument("repository", help="repository to operate from")
    parser.add_argument("--hash", help="shared server password hash")
    parser.add_argument("--mac", help="calling mac")
    parser.add_argument("--token", help="token to confirm")
    try:
        args, cmd = parser.parse_known_args()
        if not os.path.exists(args.repository):
            raise ConfigException("repository does not exist")
        if args.mode == "validate":
            if not cmd or len(cmd) == 0 or not args.token or not args.mac:
                raise ConfigException("command, token, and mac required")
            _validate(args.repository, cmd, args.token, args.mac)
        elif args.mode == "server":
            if not args.hash:
                raise ConfigException("hash required")
            _server(args.repository, args.hash)
        elif args.mode == "fetch":
            _fetch(args.repository)
        elif args.mode in ["build", "rebuild"]:
            force = args.mode == "rebuild"
            _build(args.repository, force)
        else:
            raise ConfigException("unknown mode: {}".format(args.mode))
    except Exception as e:
        _stdout("configuration process failed")
        _stdout(e)
        exit(1)


if __name__ == "__main__":
    main()
